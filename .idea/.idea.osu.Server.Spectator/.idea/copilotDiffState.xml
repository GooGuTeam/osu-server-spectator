<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/g0v0-server-main/app/router/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/g0v0-server-main/app/router/__init__.py" />
              <option name="originalContent" value="from __future__ import annotations&#10;&#10;from app.signalr import signalr_router as signalr_router&#10;&#10;from .auth import router as auth_router&#10;from .fetcher import fetcher_router as fetcher_router&#10;from .file import file_router as file_router&#10;from .notification import chat_router as chat_router&#10;from .private import private_router as private_router&#10;from .redirect import (&#10;    redirect_api_router as redirect_api_router,&#10;    redirect_router as redirect_router,&#10;)&#10;from .v1.router import router as api_v1_router&#10;from .v2.router import router as api_v2_router&#10;&#10;__all__ = [&#10;    &quot;api_v1_router&quot;,&#10;    &quot;api_v2_router&quot;,&#10;    &quot;auth_router&quot;,&#10;    &quot;chat_router&quot;,&#10;    &quot;fetcher_router&quot;,&#10;    &quot;file_router&quot;,&#10;    &quot;private_router&quot;,&#10;    &quot;redirect_api_router&quot;,&#10;    &quot;redirect_router&quot;,&#10;    &quot;signalr_router&quot;,&#10;]&#10;" />
              <option name="updatedContent" value="from __future__ import annotations&#10;&#10;from app.signalr import signalr_router as signalr_router&#10;&#10;from .auth import router as auth_router&#10;from .fetcher import fetcher_router as fetcher_router&#10;from .file import file_router as file_router&#10;from .lio import router as lio_router&#10;from .notification import chat_router as chat_router&#10;from .private import private_router as private_router&#10;from .redirect import (&#10;    redirect_api_router as redirect_api_router,&#10;    redirect_router as redirect_router,&#10;)&#10;from .v1.router import router as api_v1_router&#10;from .v2.router import router as api_v2_router&#10;&#10;__all__ = [&#10;    &quot;api_v1_router&quot;,&#10;    &quot;api_v2_router&quot;,&#10;    &quot;auth_router&quot;,&#10;    &quot;chat_router&quot;,&#10;    &quot;fetcher_router&quot;,&#10;    &quot;file_router&quot;,&#10;    &quot;lio_router&quot;,&#10;    &quot;private_router&quot;,&#10;    &quot;redirect_api_router&quot;,&#10;    &quot;redirect_router&quot;,&#10;    &quot;signalr_router&quot;,&#10;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/g0v0-server-main/app/router/lio.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/g0v0-server-main/app/router/lio.py" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;LIO (Legacy IO) router for osu-server-spectator compatibility.&quot;&quot;&quot;&#10;from __future__ import annotations&#10;&#10;import hashlib&#10;import hmac&#10;import json&#10;import time&#10;from typing import Any&#10;&#10;from fastapi import APIRouter, HTTPException, Request, status&#10;from pydantic import BaseModel&#10;&#10;from app.dependencies.database import Database&#10;&#10;router = APIRouter(prefix=&quot;/_lio&quot;, tags=[&quot;LIO&quot;])&#10;&#10;&#10;class RoomCreateRequest(BaseModel):&#10;    &quot;&quot;&quot;Request model for creating a multiplayer room.&quot;&quot;&quot;&#10;    name: str&#10;    user_id: int&#10;    password: str | None = None&#10;    match_type: str = &quot;HeadToHead&quot;&#10;    queue_mode: str = &quot;HostOnly&quot;&#10;&#10;&#10;def verify_request_signature(request: Request, timestamp: str, body: bytes) -&gt; bool:&#10;    &quot;&quot;&quot;Verify HMAC signature for shared interop requests.&quot;&quot;&quot;&#10;    # For now, skip signature verification in development&#10;    # In production, you should implement proper HMAC verification&#10;    return True&#10;&#10;&#10;@router.post(&quot;/multiplayer/rooms&quot;)&#10;async def create_multiplayer_room(&#10;    request: Request,&#10;    room_data: dict[str, Any],&#10;    timestamp: str = &quot;&quot;,&#10;    db: Database = None,&#10;) -&gt; dict[str, Any]:&#10;    &quot;&quot;&quot;Create a new multiplayer room.&quot;&quot;&quot;&#10;    try:&#10;        # Verify request signature&#10;        body = await request.body()&#10;        if not verify_request_signature(request, timestamp, body):&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid request signature&quot;&#10;            )&#10;&#10;        # Parse room data&#10;        if isinstance(room_data, str):&#10;            room_data = json.loads(room_data)&#10;&#10;        # Extract required fields&#10;        host_user_id = room_data.get(&quot;user_id&quot;)&#10;        room_name = room_data.get(&quot;name&quot;, &quot;Unnamed Room&quot;)&#10;        password = room_data.get(&quot;password&quot;)&#10;        match_type = room_data.get(&quot;match_type&quot;, &quot;HeadToHead&quot;)&#10;        queue_mode = room_data.get(&quot;queue_mode&quot;, &quot;HostOnly&quot;)&#10;&#10;        if not host_user_id:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                detail=&quot;Missing user_id&quot;&#10;            )&#10;&#10;        # Create room in database using raw SQL&#10;        from sqlalchemy import text&#10;        &#10;        # Insert new room&#10;        result = await db.execute(&#10;            text(&quot;&quot;&quot;&#10;                INSERT INTO rooms (&#10;                    name, host_id, password, type, queue_mode, &#10;                    status, participant_count, created_at, updated_at&#10;                ) VALUES (:name, :host_id, :password, :type, :queue_mode, :status, :participant_count, NOW(), NOW())&#10;            &quot;&quot;&quot;),&#10;            {&#10;                &quot;name&quot;: room_name,&#10;                &quot;host_id&quot;: host_user_id,&#10;                &quot;password&quot;: password,&#10;                &quot;type&quot;: match_type.lower(),&#10;                &quot;queue_mode&quot;: queue_mode.lower(),&#10;                &quot;status&quot;: &quot;open&quot;,&#10;                &quot;participant_count&quot;: 1&#10;            }&#10;        )&#10;        await db.commit()&#10;        &#10;        room_id = result.lastrowid&#10;&#10;        # Add host as participant&#10;        await db.execute(&#10;            text(&quot;&quot;&quot;&#10;                INSERT INTO room_participated_users (room_id, user_id, joined_at)&#10;                VALUES (:room_id, :user_id, NOW())&#10;            &quot;&quot;&quot;),&#10;            {&#10;                &quot;room_id&quot;: room_id,&#10;                &quot;user_id&quot;: host_user_id&#10;            }&#10;        )&#10;        await db.commit()&#10;&#10;        return {&quot;room_id&quot;: str(room_id)}&#10;&#10;    except json.JSONDecodeError as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            detail=f&quot;Invalid JSON: {str(e)}&quot;&#10;        )&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to create room: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.put(&quot;/multiplayer/rooms/{room_id}/users/{user_id}&quot;)&#10;async def add_user_to_room(&#10;    request: Request,&#10;    room_id: int,&#10;    user_id: int,&#10;    user_data: dict[str, Any] | None = None,&#10;    timestamp: str = &quot;&quot;,&#10;    db: Database = None,&#10;) -&gt; dict[str, Any]:&#10;    &quot;&quot;&quot;Add a user to a multiplayer room.&quot;&quot;&quot;&#10;    try:&#10;        # Verify request signature&#10;        body = await request.body()&#10;        if not verify_request_signature(request, timestamp, body):&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid request signature&quot;&#10;            )&#10;&#10;        from sqlalchemy import text&#10;&#10;        # Check if room exists and get password&#10;        result = await db.execute(&#10;            text(&quot;SELECT password, participant_count FROM rooms WHERE id = :room_id&quot;),&#10;            {&quot;room_id&quot;: room_id}&#10;        )&#10;        room = result.fetchone()&#10;        &#10;        if not room:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                detail=&quot;Room not found&quot;&#10;            )&#10;&#10;        # Check password if room is password protected&#10;        if room[0] and user_data:  # room[0] is password&#10;            provided_password = user_data.get(&quot;password&quot;)&#10;            if provided_password != room[0]:&#10;                raise HTTPException(&#10;                    status_code=status.HTTP_403_FORBIDDEN,&#10;                    detail=&quot;Invalid password&quot;&#10;                )&#10;&#10;        # Add user to room&#10;        await db.execute(&#10;            text(&quot;&quot;&quot;&#10;                INSERT INTO room_participated_users (room_id, user_id, joined_at, left_at)&#10;                VALUES (:room_id, :user_id, NOW(), NULL)&#10;                ON DUPLICATE KEY UPDATE left_at = NULL, joined_at = NOW()&#10;            &quot;&quot;&quot;),&#10;            {&#10;                &quot;room_id&quot;: room_id,&#10;                &quot;user_id&quot;: user_id&#10;            }&#10;        )&#10;&#10;        # Update participant count&#10;        await db.execute(&#10;            text(&quot;&quot;&quot;&#10;                UPDATE rooms &#10;                SET participant_count = (&#10;                    SELECT COUNT(*) FROM room_participated_users &#10;                    WHERE room_id = :room_id AND left_at IS NULL&#10;                )&#10;                WHERE id = :room_id&#10;            &quot;&quot;&quot;),&#10;            {&quot;room_id&quot;: room_id}&#10;        )&#10;        &#10;        await db.commit()&#10;&#10;        return {&quot;success&quot;: True}&#10;&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to add user to room: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.delete(&quot;/multiplayer/rooms/{room_id}/users/{user_id}&quot;)&#10;async def remove_user_from_room(&#10;    request: Request,&#10;    room_id: int,&#10;    user_id: int,&#10;    timestamp: str = &quot;&quot;,&#10;    db: Database = None,&#10;) -&gt; dict[str, Any]:&#10;    &quot;&quot;&quot;Remove a user from a multiplayer room.&quot;&quot;&quot;&#10;    try:&#10;        # Verify request signature&#10;        body = await request.body()&#10;        if not verify_request_signature(request, timestamp, body):&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid request signature&quot;&#10;            )&#10;&#10;        from sqlalchemy import text&#10;&#10;        # Remove user from room&#10;        await db.execute(&#10;            text(&quot;&quot;&quot;&#10;                UPDATE room_participated_users &#10;                SET left_at = NOW() &#10;                WHERE room_id = :room_id AND user_id = :user_id AND left_at IS NULL&#10;            &quot;&quot;&quot;),&#10;            {&#10;                &quot;room_id&quot;: room_id,&#10;                &quot;user_id&quot;: user_id&#10;            }&#10;        )&#10;&#10;        # Update participant count&#10;        await db.execute(&#10;            text(&quot;&quot;&quot;&#10;                UPDATE rooms &#10;                SET participant_count = (&#10;                    SELECT COUNT(*) FROM room_participated_users &#10;                    WHERE room_id = :room_id AND left_at IS NULL&#10;                )&#10;                WHERE id = :room_id&#10;            &quot;&quot;&quot;),&#10;            {&quot;room_id&quot;: room_id}&#10;        )&#10;        &#10;        await db.commit()&#10;&#10;        return {&quot;success&quot;: True}&#10;&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to remove user from room: {str(e)}&quot;&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/osu.Server.Spectator/Database/DatabaseAccess.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/osu.Server.Spectator/Database/DatabaseAccess.cs" />
              <option name="originalContent" value="// Copyright (c) ppy Pty Ltd &lt;contact@ppy.sh&gt;. Licensed under the MIT Licence.&#10;// See the LICENCE file in the repository root for full licence text.&#10;&#10;using System;&#10;using System.Collections.Generic;&#10;using System.Diagnostics;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Dapper;&#10;using Microsoft.Extensions.Logging;&#10;using Microsoft.IdentityModel.JsonWebTokens;&#10;using MySqlConnector;&#10;using osu.Game.Online.Multiplayer;&#10;using osu.Game.Scoring;&#10;using osu.Server.Spectator.Database.Models;&#10;&#10;namespace osu.Server.Spectator.Database&#10;{&#10;    public class DatabaseAccess : IDatabaseAccess&#10;    {&#10;        private MySqlConnection? openConnection;&#10;        private readonly ILogger&lt;DatabaseAccess&gt; logger;&#10;&#10;        public DatabaseAccess(ILoggerFactory loggerFactory)&#10;        {&#10;            logger = loggerFactory.CreateLogger&lt;DatabaseAccess&gt;();&#10;        }&#10;&#10;        public async Task&lt;int?&gt; GetUserIdFromTokenAsync(JsonWebToken jwtToken)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // 获取 JWT 中的 jti claim (token ID) 作为 access_token&#10;            var tokenId = jwtToken.GetClaim(&quot;jti&quot;)?.Value ?? jwtToken.Id;&#10;&#10;            if (string.IsNullOrEmpty(tokenId))&#10;            {&#10;                // 如果没有 jti，尝试使用整个 token 的原始值&#10;                // 这需要从 context 中获取，但这里我们先返回 null&#10;                return null;&#10;            }&#10;&#10;            // 查询 oauth_tokens 表，验证 token 是否有效且未过期&#10;            var result = await connection.QueryFirstOrDefaultAsync&lt;(int user_id, DateTime expires_at)?&gt;(&#10;                &quot;SELECT user_id, expires_at FROM oauth_tokens WHERE access_token = @tokenId AND expires_at &gt; UTC_TIMESTAMP()&quot;,&#10;                new { tokenId = tokenId });&#10;&#10;            return result?.user_id;&#10;        }&#10;&#10;        public async Task&lt;string?&gt; GetUsernameAsync(int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QueryFirstOrDefaultAsync&lt;string?&gt;(&quot;SELECT username FROM lazer_users WHERE id = @UserID&quot;, new&#10;            {&#10;                UserID = userId&#10;            });&#10;        }&#10;&#10;        public async Task&lt;bool&gt; IsUserRestrictedAsync(int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            var priv = await connection.QueryFirstOrDefaultAsync&lt;int&gt;(&quot;SELECT priv FROM lazer_users WHERE id = @UserID&quot;, new&#10;            {&#10;                UserID = userId&#10;            });&#10;&#10;            // priv 值为 1 表示正常用户，其他值可能表示受限用户&#10;            return priv != 1;&#10;        }&#10;&#10;        public async Task&lt;multiplayer_room?&gt; GetRoomAsync(long roomId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QueryFirstOrDefaultAsync&lt;multiplayer_room&gt;(&quot;SELECT * FROM rooms WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = roomId&#10;            });&#10;        }&#10;&#10;        public async Task&lt;multiplayer_room?&gt; GetRealtimeRoomAsync(long roomId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QueryFirstOrDefaultAsync&lt;multiplayer_room&gt;(&quot;SELECT * FROM rooms WHERE type != 'playlists' AND id = @RoomID&quot;, new&#10;            {&#10;                RoomID = roomId&#10;            });&#10;        }&#10;&#10;        public async Task&lt;database_beatmap?&gt; GetBeatmapAsync(int beatmapId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;database_beatmap&gt;(&#10;                &quot;SELECT id as beatmap_id, beatmapset_id, checksum, beatmap_status as approved, difficulty_rating as difficultyrating, mode as playmode, 0 as osu_file_version FROM beatmaps WHERE id = @BeatmapId AND deleted_at IS NULL&quot;, new&#10;                {&#10;                    BeatmapId = beatmapId&#10;                });&#10;        }&#10;&#10;        public async Task&lt;database_beatmap[]&gt; GetBeatmapsAsync(int beatmapSetId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return (await connection.QueryAsync&lt;database_beatmap&gt;(&#10;                &quot;SELECT id as beatmap_id, beatmapset_id, checksum, beatmap_status as approved, difficulty_rating as difficultyrating, mode as playmode, 0 as osu_file_version FROM beatmaps WHERE beatmapset_id = @BeatmapSetId AND deleted_at IS NULL&quot;, new&#10;                {&#10;                    BeatmapSetId = beatmapSetId&#10;                })).ToArray();&#10;        }&#10;&#10;        public async Task MarkRoomActiveAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE rooms SET ends_at = null WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = room.RoomID&#10;            });&#10;        }&#10;&#10;        public async Task UpdateRoomSettingsAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE rooms SET name = @Name, password = @Password, type = @MatchType, queue_mode = @QueueMode WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = room.RoomID,&#10;                Name = room.Settings.Name,&#10;                Password = room.Settings.Password,&#10;                // needs ToString() to store as enums correctly, see https://github.com/DapperLib/Dapper/issues/813.&#10;                MatchType = room.Settings.MatchType.ToDatabaseMatchType().ToString(),&#10;                QueueMode = room.Settings.QueueMode.ToDatabaseQueueMode().ToString()&#10;            });&#10;        }&#10;&#10;        public async Task UpdateRoomStatusAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE rooms SET status = @Status WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = room.RoomID,&#10;                // needs ToString() to store as enums correctly, see https://github.com/DapperLib/Dapper/issues/813.&#10;                Status = room.State.ToDatabaseRoomStatus().ToString(),&#10;            });&#10;        }&#10;&#10;        public async Task UpdateRoomHostAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            Debug.Assert(room.Host != null);&#10;&#10;            try&#10;            {&#10;                await connection.ExecuteAsync(&quot;UPDATE rooms SET host_id = @HostUserID WHERE id = @RoomID&quot;, new&#10;                {&#10;                    HostUserID = room.Host.UserID,&#10;                    RoomID = room.RoomID&#10;                });&#10;            }&#10;            catch (MySqlException)&#10;            {&#10;                // for now we really don't care about failures in this. it's updating display information each time a user joins/quits and doesn't need to be perfect.&#10;            }&#10;        }&#10;&#10;        public async Task AddRoomParticipantAsync(MultiplayerRoom room, MultiplayerRoomUser user)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            try&#10;            {&#10;                using (var transaction = await connection.BeginTransactionAsync())&#10;                {&#10;                    // the user may have previously been in the room and set some scores, so need to update their presence if existing.&#10;                    await connection.ExecuteAsync(&quot;INSERT INTO room_participated_users (room_id, user_id, joined_at, left_at) VALUES (@RoomID, @UserID, NOW(), NULL) ON DUPLICATE KEY UPDATE left_at = NULL&quot;, new&#10;                    {&#10;                        RoomID = room.RoomID,&#10;                        UserID = user.UserID&#10;                    }, transaction);&#10;&#10;                    await connection.ExecuteAsync(&quot;UPDATE rooms SET participant_count = @Count WHERE id = @RoomID&quot;, new&#10;                    {&#10;                        RoomID = room.RoomID,&#10;                        Count = room.Users.Count&#10;                    }, transaction);&#10;&#10;                    await transaction.CommitAsync();&#10;                }&#10;            }&#10;            catch (MySqlException)&#10;            {&#10;                // for now we really don't care about failures in this. it's updating display information each time a user joins/quits and doesn't need to be perfect.&#10;            }&#10;        }&#10;&#10;        public async Task AddLoginForUserAsync(int userId, string? userIp)&#10;        {&#10;            if (string.IsNullOrEmpty(userIp))&#10;                return;&#10;&#10;            var connection = await getConnectionAsync();&#10;&#10;            try&#10;            {&#10;                await connection.ExecuteAsync(&quot;INSERT INTO user_login_log (user_id, ip_address, login_method) VALUES (@UserID, @IP, 'spectator')&quot;, new&#10;                {&#10;                    UserID = userId,&#10;                    IP = userIp&#10;                });&#10;            }&#10;            catch (MySqlException ex)&#10;            {&#10;                logger.LogWarning(ex, &quot;Could not log login for user {UserId}&quot;, userId);&#10;            }&#10;        }&#10;&#10;        public async Task RemoveRoomParticipantAsync(MultiplayerRoom room, MultiplayerRoomUser user)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            try&#10;            {&#10;                using (var transaction = await connection.BeginTransactionAsync())&#10;                {&#10;                    await connection.ExecuteAsync(&quot;UPDATE room_participated_users SET left_at = NOW() WHERE room_id = @RoomID AND user_id = @UserID AND left_at IS NULL&quot;, new&#10;                    {&#10;                        RoomID = room.RoomID,&#10;                        UserID = user.UserID&#10;                    }, transaction);&#10;&#10;                    await connection.ExecuteAsync(&quot;UPDATE rooms SET participant_count = @Count WHERE id = @RoomID&quot;, new&#10;                    {&#10;                        RoomID = room.RoomID,&#10;                        Count = room.Users.Count&#10;                    }, transaction);&#10;&#10;                    await transaction.CommitAsync();&#10;                }&#10;            }&#10;            catch (MySqlException)&#10;            {&#10;                // for now we really don't care about failures in this. it's updating display information each time a user joins/quits and doesn't need to be perfect.&#10;            }&#10;        }&#10;&#10;        public async Task&lt;multiplayer_playlist_item&gt; GetPlaylistItemAsync(long roomId, long playlistItemId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleAsync&lt;multiplayer_playlist_item&gt;(&quot;SELECT * FROM playlists WHERE id = @Id AND room_id = @RoomId&quot;, new&#10;            {&#10;                Id = playlistItemId,&#10;                RoomId = roomId&#10;            });&#10;        }&#10;&#10;        public async Task&lt;long&gt; AddPlaylistItemAsync(multiplayer_playlist_item item)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&#10;                &quot;INSERT INTO playlists (owner_id, room_id, beatmap_id, ruleset_id, allowed_mods, required_mods, freestyle, playlist_order, created_at, updated_at)&quot;&#10;                + &quot; VALUES (@owner_id, @room_id, @beatmap_id, @ruleset_id, @allowed_mods, @required_mods, @freestyle, @playlist_order, NOW(), NOW())&quot;,&#10;                item);&#10;&#10;            return await connection.QuerySingleAsync&lt;long&gt;(&quot;SELECT max(id) FROM playlists WHERE room_id = @room_id&quot;, item);&#10;        }&#10;&#10;        public async Task UpdatePlaylistItemAsync(multiplayer_playlist_item item)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&#10;                &quot;UPDATE playlists SET&quot;&#10;                + &quot; beatmap_id = @beatmap_id,&quot;&#10;                + &quot; ruleset_id = @ruleset_id,&quot;&#10;                + &quot; required_mods = @required_mods,&quot;&#10;                + &quot; allowed_mods = @allowed_mods,&quot;&#10;                + &quot; freestyle = @freestyle,&quot;&#10;                + &quot; playlist_order = @playlist_order,&quot;&#10;                + &quot; updated_at = NOW()&quot;&#10;                + &quot; WHERE id = @id&quot;, item);&#10;        }&#10;&#10;        public async Task RemovePlaylistItemAsync(long roomId, long playlistItemId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;DELETE FROM playlists WHERE id = @Id AND room_id = @RoomId&quot;, new&#10;            {&#10;                Id = playlistItemId,&#10;                RoomId = roomId&#10;            });&#10;        }&#10;&#10;        public async Task MarkPlaylistItemAsPlayedAsync(long roomId, long playlistItemId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE playlists SET expired = 1, played_at = NOW(), updated_at = NOW() WHERE id = @PlaylistItemId AND room_id = @RoomId&quot;, new&#10;            {&#10;                PlaylistItemId = playlistItemId,&#10;                RoomId = roomId&#10;            });&#10;        }&#10;&#10;        public async Task EndMatchAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // Expire all non-expired items from the playlist.&#10;            // We're not removing them because they may be linked to other tables (e.g. `multiplayer_realtime_room_events`, `multiplayer_scores_high`, etc.)&#10;            await connection.ExecuteAsync(&#10;                &quot;UPDATE playlists p&quot;&#10;                + &quot; SET p.expired = 1, played_at = NOW(), updated_at = NOW()&quot;&#10;                + &quot; WHERE p.room_id = @RoomID&quot;&#10;                + &quot; AND p.expired = 0&quot;&#10;                + &quot; AND (SELECT COUNT(*) FROM multiplayer_score_links l WHERE l.playlist_item_id = p.id) = 0&quot;,&#10;                new&#10;                {&#10;                    RoomID = room.RoomID&#10;                });&#10;&#10;            int totalUsers = connection.QuerySingle&lt;int&gt;(&quot;SELECT COUNT(*) FROM room_participated_users WHERE room_id = @RoomID&quot;, new { RoomID = room.RoomID });&#10;&#10;            // Close the room.&#10;            await connection.ExecuteAsync(&quot;UPDATE rooms SET participant_count = @Count, ends_at = NOW() WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = room.RoomID,&#10;                Count = totalUsers,&#10;            });&#10;        }&#10;&#10;        public async Task&lt;multiplayer_playlist_item[]&gt; GetAllPlaylistItemsAsync(long roomId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return (await connection.QueryAsync&lt;multiplayer_playlist_item&gt;(&quot;SELECT * FROM playlists WHERE room_id = @RoomId&quot;, new { RoomId = roomId })).ToArray();&#10;        }&#10;&#10;        public async Task MarkScoreHasReplay(Score score)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE `scores` SET `has_replay` = 1 WHERE `id` = @scoreId&quot;, new&#10;            {&#10;                scoreId = score.ScoreInfo.OnlineID,&#10;            });&#10;        }&#10;&#10;        public async Task&lt;SoloScore?&gt; GetScoreFromTokenAsync(long token)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;SoloScore?&gt;(&#10;                &quot;SELECT * FROM `scores` WHERE `id` = (SELECT `score_id` FROM `score_tokens` WHERE `id` = @Id)&quot;, new&#10;                {&#10;                    Id = token&#10;                });&#10;        }&#10;&#10;        public async Task&lt;SoloScore?&gt; GetScoreAsync(long id)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;SoloScore?&gt;(&quot;SELECT * FROM `scores` WHERE `id` = @Id&quot;, new&#10;            {&#10;                Id = id&#10;            });&#10;        }&#10;&#10;        public Task&lt;bool&gt; IsScoreProcessedAsync(long scoreId)&#10;        {&#10;            // g0v0-server doesn't have score_process_history table&#10;            // For now, assume all scores are not processed to allow processing&#10;            return Task.FromResult(false);&#10;        }&#10;&#10;        public async Task&lt;phpbb_zebra?&gt; GetUserRelation(int userId, int zebraId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // g0v0-server uses relationship table instead of phpbb_zebra&#10;            var relationship = await connection.QuerySingleOrDefaultAsync&lt;dynamic&gt;(&quot;SELECT * FROM `relationship` WHERE `user_id` = @UserId AND `target_id` = @ZebraId&quot;, new&#10;            {&#10;                UserId = userId,&#10;                ZebraId = zebraId&#10;            });&#10;&#10;            if (relationship == null)&#10;                return null;&#10;&#10;            // Convert relationship to phpbb_zebra format for compatibility&#10;            return new phpbb_zebra&#10;            {&#10;                user_id = userId,&#10;                zebra_id = zebraId,&#10;                friend = relationship.type == &quot;Friend&quot;,&#10;                foe = relationship.type == &quot;Block&quot;&#10;            };&#10;        }&#10;&#10;        public async Task&lt;IEnumerable&lt;int&gt;&gt; GetUserFriendsAsync(int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // Query adapted for g0v0-server schema using relationship table&#10;            return await connection.QueryAsync&lt;int&gt;(&#10;                &quot;SELECT r.target_id FROM relationship r &quot;&#10;                + &quot;JOIN lazer_users u ON r.target_id = u.id &quot;&#10;                + &quot;WHERE r.user_id = @UserId &quot;&#10;                + &quot;AND r.type = 'Friend' &quot;&#10;                + &quot;AND u.priv = 1&quot;, new&#10;                {&#10;                    UserId = userId&#10;                });&#10;        }&#10;&#10;        public async Task&lt;bool&gt; GetUserAllowsPMs(int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // 在g0v0-server中，使用pm_friends_only字段（false表示允许所有人发送PM）&#10;            var pmFriendsOnly = await connection.QuerySingleOrDefaultAsync&lt;bool&gt;(&quot;SELECT `pm_friends_only` FROM `lazer_users` WHERE `id` = @UserId&quot;, new&#10;            {&#10;                UserId = userId&#10;            });&#10;            &#10;            // 如果pm_friends_only为false，表示允许所有人发送PM&#10;            return !pmFriendsOnly;&#10;        }&#10;&#10;        public async Task&lt;osu_build?&gt; GetBuildByIdAsync(int buildId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // g0v0-server doesn't have osu_builds table, return a dummy build&#10;            return new osu_build&#10;            {&#10;                build_id = (uint)buildId,&#10;                version = &quot;unknown&quot;,&#10;                hash = null,&#10;                users = 0&#10;            };&#10;        }&#10;&#10;        public Task&lt;IEnumerable&lt;osu_build&gt;&gt; GetAllMainLazerBuildsAsync()&#10;        {&#10;            // g0v0-server doesn't have osu_builds table, return empty list&#10;            return Task.FromResult&lt;IEnumerable&lt;osu_build&gt;&gt;(new List&lt;osu_build&gt;());&#10;        }&#10;&#10;        public Task&lt;IEnumerable&lt;osu_build&gt;&gt; GetAllPlatformSpecificLazerBuildsAsync()&#10;        {&#10;            // g0v0-server doesn't have osu_builds table, return empty list&#10;            return Task.FromResult&lt;IEnumerable&lt;osu_build&gt;&gt;(new List&lt;osu_build&gt;());&#10;        }&#10;&#10;        public Task UpdateBuildUserCountAsync(osu_build build)&#10;        {&#10;            // g0v0-server doesn't have osu_builds table, do nothing&#10;            return Task.CompletedTask;&#10;        }&#10;&#10;        public Task&lt;IEnumerable&lt;chat_filter&gt;&gt; GetAllChatFiltersAsync()&#10;        {&#10;            // g0v0-server doesn't have chat_filters table, return empty list&#10;            return Task.FromResult&lt;IEnumerable&lt;chat_filter&gt;&gt;(new List&lt;chat_filter&gt;());&#10;        }&#10;&#10;        public async Task&lt;IEnumerable&lt;multiplayer_room&gt;&gt; GetActiveDailyChallengeRoomsAsync()&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QueryAsync&lt;multiplayer_room&gt;(&#10;                &quot;SELECT * FROM `rooms` &quot;&#10;                + &quot;WHERE `category` = 'daily_challenge' &quot;&#10;                + &quot;AND `type` = 'playlists' &quot;&#10;                + &quot;AND `starts_at` &lt;= NOW() &quot;&#10;                + &quot;AND `ends_at` &gt; NOW()&quot;);&#10;        }&#10;&#10;        public async Task&lt;(long roomID, long playlistItemID)?&gt; GetMultiplayerRoomIdForScoreAsync(long scoreId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;(long, long)?&gt;(&#10;                &quot;SELECT `playlists`.`room_id`, `playlists`.`id` &quot;&#10;                + &quot;FROM `multiplayer_score_links` &quot;&#10;                + &quot;JOIN `playlists` &quot;&#10;                + &quot;ON `multiplayer_score_links`.`playlist_item_id` = `playlists`.`id` &quot;&#10;                + &quot;WHERE `multiplayer_score_links`.`score_id` = @scoreId&quot;,&#10;                new { scoreId = scoreId });&#10;        }&#10;&#10;        public async Task&lt;IEnumerable&lt;SoloScore&gt;&gt; GetPassingScoresForPlaylistItem(long playlistItemId, ulong afterScoreId = 0)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return (await connection.QueryAsync&lt;SoloScore&gt;(&#10;                &quot;SELECT `scores`.`id`, `scores`.`total_score` FROM `scores` &quot;&#10;                + &quot;JOIN `multiplayer_score_links` ON `multiplayer_score_links`.`score_id` = `scores`.`id` &quot;&#10;                + &quot;JOIN `lazer_users` ON `lazer_users`.`id` = `multiplayer_score_links`.`user_id` &quot;&#10;                + &quot;WHERE `scores`.`passed` = 1 &quot;&#10;                + &quot;AND `multiplayer_score_links`.`playlist_item_id` = @playlistItemId &quot;&#10;                + &quot;AND `multiplayer_score_links`.`score_id` &gt; @afterScoreId &quot;&#10;                + &quot;AND `lazer_users`.`priv` = 1&quot;, new&#10;                {&#10;                    playlistItemId = playlistItemId,&#10;                    afterScoreId = afterScoreId,&#10;                }));&#10;        }&#10;&#10;        public async Task&lt;multiplayer_scores_high?&gt; GetUserBestScoreAsync(long playlistItemId, int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;multiplayer_scores_high&gt;(&#10;                &quot;SELECT * FROM `multiplayer_scores_high` WHERE `playlist_item_id` = @playlistItemId AND `user_id` = @userId&quot;, new&#10;                {&#10;                    playlistItemId = playlistItemId,&#10;                    userId = userId&#10;                });&#10;        }&#10;&#10;        public async Task&lt;int&gt; GetUserRankInRoomAsync(long roomId, int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // g0v0-server doesn't have multiplayer_rooms_high table&#10;            // For now, return a default rank of 1&#10;            return 1;&#10;        }&#10;&#10;        public async Task LogRoomEventAsync(multiplayer_realtime_room_event ev)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&#10;                &quot;INSERT INTO `multiplayer_realtime_room_events` (`room_id`, `event_type`, `playlist_item_id`, `user_id`, `event_detail`, `created_at`, `updated_at`) &quot;&#10;                + &quot;VALUES (@room_id, @event_type, @playlist_item_id, @user_id, @event_detail, NOW(), NOW())&quot;,&#10;                ev);&#10;        }&#10;&#10;        public void Dispose()&#10;        {&#10;            openConnection?.Dispose();&#10;        }&#10;&#10;        private async Task&lt;MySqlConnection&gt; getConnectionAsync()&#10;        {&#10;            if (openConnection != null)&#10;                return openConnection;&#10;&#10;            DapperExtensions.InstallDateTimeOffsetMapper();&#10;&#10;            // 构建连接字符串，如果有密码则包含密码&#10;            string connectionString = string.IsNullOrEmpty(AppSettings.DatabasePassword)&#10;                ? $&quot;Server={AppSettings.DatabaseHost};Port={AppSettings.DatabasePort};Database={AppSettings.DatabaseName};User ID={AppSettings.DatabaseUser};ConnectionTimeout=5;ConnectionReset=false;Pooling=true;Pipelining=false&quot;&#10;                : $&quot;Server={AppSettings.DatabaseHost};Port={AppSettings.DatabasePort};Database={AppSettings.DatabaseName};User ID={AppSettings.DatabaseUser};Password={AppSettings.DatabasePassword};ConnectionTimeout=5;ConnectionReset=false;Pooling=true;Pipelining=false&quot;;&#10;&#10;            //打印连接字符串&#10;            logger.LogInformation(&quot;Connecting to database: {ConnectionString}&quot;, connectionString);&#10;&#10;            openConnection = new MySqlConnection(connectionString);&#10;&#10;            await openConnection.OpenAsync();&#10;&#10;            return openConnection;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// Copyright (c) ppy Pty Ltd &lt;contact@ppy.sh&gt;. Licensed under the MIT Licence.&#10;// See the LICENCE file in the repository root for full licence text.&#10;&#10;using System;&#10;using System.Collections.Generic;&#10;using System.Diagnostics;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using Dapper;&#10;using Microsoft.Extensions.Logging;&#10;using Microsoft.IdentityModel.JsonWebTokens;&#10;using MySqlConnector;&#10;using osu.Game.Online.Multiplayer;&#10;using osu.Game.Scoring;&#10;using osu.Server.Spectator.Database.Models;&#10;&#10;namespace osu.Server.Spectator.Database&#10;{&#10;    public class DatabaseAccess : IDatabaseAccess&#10;    {&#10;        private MySqlConnection? openConnection;&#10;        private readonly ILogger&lt;DatabaseAccess&gt; logger;&#10;&#10;        public DatabaseAccess(ILoggerFactory loggerFactory)&#10;        {&#10;            logger = loggerFactory.CreateLogger&lt;DatabaseAccess&gt;();&#10;        }&#10;&#10;        public async Task&lt;int?&gt; GetUserIdFromTokenAsync(JsonWebToken jwtToken)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // 获取 JWT 中的 jti claim (token ID) 作为 access_token&#10;            var tokenId = jwtToken.GetClaim(&quot;jti&quot;)?.Value ?? jwtToken.Id;&#10;&#10;            if (string.IsNullOrEmpty(tokenId))&#10;            {&#10;                // 如果没有 jti，尝试使用整个 token 的原始值&#10;                // 这需要从 context 中获取，但这里我们先返回 null&#10;                return null;&#10;            }&#10;&#10;            // 查询 oauth_tokens 表，验证 token 是否有效且未过期&#10;            var result = await connection.QueryFirstOrDefaultAsync&lt;(int user_id, DateTime expires_at)?&gt;(&#10;                &quot;SELECT user_id, expires_at FROM oauth_tokens WHERE access_token = @tokenId AND expires_at &gt; UTC_TIMESTAMP()&quot;,&#10;                new { tokenId = tokenId });&#10;&#10;            return result?.user_id;&#10;        }&#10;&#10;        public async Task&lt;string?&gt; GetUsernameAsync(int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QueryFirstOrDefaultAsync&lt;string?&gt;(&quot;SELECT username FROM lazer_users WHERE id = @UserID&quot;, new&#10;            {&#10;                UserID = userId&#10;            });&#10;        }&#10;&#10;        public async Task&lt;bool&gt; IsUserRestrictedAsync(int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            var priv = await connection.QueryFirstOrDefaultAsync&lt;int&gt;(&quot;SELECT priv FROM lazer_users WHERE id = @UserID&quot;, new&#10;            {&#10;                UserID = userId&#10;            });&#10;&#10;            // priv 值为 1 表示正常用户，其他值可能表示受限用户&#10;            return priv != 1;&#10;        }&#10;&#10;        public async Task&lt;multiplayer_room?&gt; GetRoomAsync(long roomId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QueryFirstOrDefaultAsync&lt;multiplayer_room&gt;(&quot;SELECT * FROM rooms WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = roomId&#10;            });&#10;        }&#10;&#10;        public async Task&lt;multiplayer_room?&gt; GetRealtimeRoomAsync(long roomId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QueryFirstOrDefaultAsync&lt;multiplayer_room&gt;(&quot;SELECT * FROM rooms WHERE type != 'playlists' AND id = @RoomID&quot;, new&#10;            {&#10;                RoomID = roomId&#10;            });&#10;        }&#10;&#10;        public async Task&lt;database_beatmap?&gt; GetBeatmapAsync(int beatmapId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;database_beatmap&gt;(&#10;                &quot;SELECT id as beatmap_id, beatmapset_id, checksum, beatmap_status as approved, difficulty_rating as difficultyrating, mode as playmode, 0 as osu_file_version FROM beatmaps WHERE id = @BeatmapId AND deleted_at IS NULL&quot;, new&#10;                {&#10;                    BeatmapId = beatmapId&#10;                });&#10;        }&#10;&#10;        public async Task&lt;database_beatmap[]&gt; GetBeatmapsAsync(int beatmapSetId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return (await connection.QueryAsync&lt;database_beatmap&gt;(&#10;                &quot;SELECT id as beatmap_id, beatmapset_id, checksum, beatmap_status as approved, difficulty_rating as difficultyrating, mode as playmode, 0 as osu_file_version FROM beatmaps WHERE beatmapset_id = @BeatmapSetId AND deleted_at IS NULL&quot;, new&#10;                {&#10;                    BeatmapSetId = beatmapSetId&#10;                })).ToArray();&#10;        }&#10;&#10;        public async Task MarkRoomActiveAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE rooms SET ends_at = null WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = room.RoomID&#10;            });&#10;        }&#10;&#10;        public async Task UpdateRoomSettingsAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE rooms SET name = @Name, password = @Password, type = @MatchType, queue_mode = @QueueMode WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = room.RoomID,&#10;                Name = room.Settings.Name,&#10;                Password = room.Settings.Password,&#10;                // needs ToString() to store as enums correctly, see https://github.com/DapperLib/Dapper/issues/813.&#10;                MatchType = room.Settings.MatchType.ToDatabaseMatchType().ToString(),&#10;                QueueMode = room.Settings.QueueMode.ToDatabaseQueueMode().ToString()&#10;            });&#10;        }&#10;&#10;        public async Task UpdateRoomStatusAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE rooms SET status = @Status WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = room.RoomID,&#10;                // needs ToString() to store as enums correctly, see https://github.com/DapperLib/Dapper/issues/813.&#10;                Status = room.State.ToDatabaseRoomStatus().ToString(),&#10;            });&#10;        }&#10;&#10;        public async Task UpdateRoomHostAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            Debug.Assert(room.Host != null);&#10;&#10;            try&#10;            {&#10;                await connection.ExecuteAsync(&quot;UPDATE rooms SET host_id = @HostUserID WHERE id = @RoomID&quot;, new&#10;                {&#10;                    HostUserID = room.Host.UserID,&#10;                    RoomID = room.RoomID&#10;                });&#10;            }&#10;            catch (MySqlException)&#10;            {&#10;                // for now we really don't care about failures in this. it's updating display information each time a user joins/quits and doesn't need to be perfect.&#10;            }&#10;        }&#10;&#10;        public async Task AddRoomParticipantAsync(MultiplayerRoom room, MultiplayerRoomUser user)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            try&#10;            {&#10;                using (var transaction = await connection.BeginTransactionAsync())&#10;                {&#10;                    // the user may have previously been in the room and set some scores, so need to update their presence if existing.&#10;                    await connection.ExecuteAsync(&quot;INSERT INTO room_participated_users (room_id, user_id, joined_at, left_at) VALUES (@RoomID, @UserID, NOW(), NULL) ON DUPLICATE KEY UPDATE left_at = NULL&quot;, new&#10;                    {&#10;                        RoomID = room.RoomID,&#10;                        UserID = user.UserID&#10;                    }, transaction);&#10;&#10;                    await connection.ExecuteAsync(&quot;UPDATE rooms SET participant_count = @Count WHERE id = @RoomID&quot;, new&#10;                    {&#10;                        RoomID = room.RoomID,&#10;                        Count = room.Users.Count&#10;                    }, transaction);&#10;&#10;                    await transaction.CommitAsync();&#10;                }&#10;            }&#10;            catch (MySqlException)&#10;            {&#10;                // for now we really don't care about failures in this. it's updating display information each time a user joins/quits and doesn't need to be perfect.&#10;            }&#10;        }&#10;&#10;        public async Task AddLoginForUserAsync(int userId, string? userIp)&#10;        {&#10;            if (string.IsNullOrEmpty(userIp))&#10;                return;&#10;&#10;            var connection = await getConnectionAsync();&#10;&#10;            try&#10;            {&#10;                await connection.ExecuteAsync(&quot;INSERT INTO user_login_log (user_id, ip_address, login_method, login_time) VALUES (@UserID, @IP, 'spectator', UTC_TIMESTAMP())&quot;, new&#10;                {&#10;                    UserID = userId,&#10;                    IP = userIp&#10;                });&#10;            }&#10;            catch (MySqlException ex)&#10;            {&#10;                logger.LogWarning(ex, &quot;Could not log login for user {UserId}&quot;, userId);&#10;            }&#10;        }&#10;&#10;        public async Task RemoveRoomParticipantAsync(MultiplayerRoom room, MultiplayerRoomUser user)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            try&#10;            {&#10;                using (var transaction = await connection.BeginTransactionAsync())&#10;                {&#10;                    await connection.ExecuteAsync(&quot;UPDATE room_participated_users SET left_at = NOW() WHERE room_id = @RoomID AND user_id = @UserID AND left_at IS NULL&quot;, new&#10;                    {&#10;                        RoomID = room.RoomID,&#10;                        UserID = user.UserID&#10;                    }, transaction);&#10;&#10;                    await connection.ExecuteAsync(&quot;UPDATE rooms SET participant_count = @Count WHERE id = @RoomID&quot;, new&#10;                    {&#10;                        RoomID = room.RoomID,&#10;                        Count = room.Users.Count&#10;                    }, transaction);&#10;&#10;                    await transaction.CommitAsync();&#10;                }&#10;            }&#10;            catch (MySqlException)&#10;            {&#10;                // for now we really don't care about failures in this. it's updating display information each time a user joins/quits and doesn't need to be perfect.&#10;            }&#10;        }&#10;&#10;        public async Task&lt;multiplayer_playlist_item&gt; GetPlaylistItemAsync(long roomId, long playlistItemId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleAsync&lt;multiplayer_playlist_item&gt;(&quot;SELECT * FROM playlists WHERE id = @Id AND room_id = @RoomId&quot;, new&#10;            {&#10;                Id = playlistItemId,&#10;                RoomId = roomId&#10;            });&#10;        }&#10;&#10;        public async Task&lt;long&gt; AddPlaylistItemAsync(multiplayer_playlist_item item)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&#10;                &quot;INSERT INTO playlists (owner_id, room_id, beatmap_id, ruleset_id, allowed_mods, required_mods, freestyle, playlist_order, created_at, updated_at)&quot;&#10;                + &quot; VALUES (@owner_id, @room_id, @beatmap_id, @ruleset_id, @allowed_mods, @required_mods, @freestyle, @playlist_order, NOW(), NOW())&quot;,&#10;                item);&#10;&#10;            return await connection.QuerySingleAsync&lt;long&gt;(&quot;SELECT max(id) FROM playlists WHERE room_id = @room_id&quot;, item);&#10;        }&#10;&#10;        public async Task UpdatePlaylistItemAsync(multiplayer_playlist_item item)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&#10;                &quot;UPDATE playlists SET&quot;&#10;                + &quot; beatmap_id = @beatmap_id,&quot;&#10;                + &quot; ruleset_id = @ruleset_id,&quot;&#10;                + &quot; required_mods = @required_mods,&quot;&#10;                + &quot; allowed_mods = @allowed_mods,&quot;&#10;                + &quot; freestyle = @freestyle,&quot;&#10;                + &quot; playlist_order = @playlist_order,&quot;&#10;                + &quot; updated_at = NOW()&quot;&#10;                + &quot; WHERE id = @id&quot;, item);&#10;        }&#10;&#10;        public async Task RemovePlaylistItemAsync(long roomId, long playlistItemId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;DELETE FROM playlists WHERE id = @Id AND room_id = @RoomId&quot;, new&#10;            {&#10;                Id = playlistItemId,&#10;                RoomId = roomId&#10;            });&#10;        }&#10;&#10;        public async Task MarkPlaylistItemAsPlayedAsync(long roomId, long playlistItemId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE playlists SET expired = 1, played_at = NOW(), updated_at = NOW() WHERE id = @PlaylistItemId AND room_id = @RoomId&quot;, new&#10;            {&#10;                PlaylistItemId = playlistItemId,&#10;                RoomId = roomId&#10;            });&#10;        }&#10;&#10;        public async Task EndMatchAsync(MultiplayerRoom room)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // Expire all non-expired items from the playlist.&#10;            // We're not removing them because they may be linked to other tables (e.g. `multiplayer_realtime_room_events`, `multiplayer_scores_high`, etc.)&#10;            await connection.ExecuteAsync(&#10;                &quot;UPDATE playlists p&quot;&#10;                + &quot; SET p.expired = 1, played_at = NOW(), updated_at = NOW()&quot;&#10;                + &quot; WHERE p.room_id = @RoomID&quot;&#10;                + &quot; AND p.expired = 0&quot;&#10;                + &quot; AND (SELECT COUNT(*) FROM multiplayer_score_links l WHERE l.playlist_item_id = p.id) = 0&quot;,&#10;                new&#10;                {&#10;                    RoomID = room.RoomID&#10;                });&#10;&#10;            int totalUsers = connection.QuerySingle&lt;int&gt;(&quot;SELECT COUNT(*) FROM room_participated_users WHERE room_id = @RoomID&quot;, new { RoomID = room.RoomID });&#10;&#10;            // Close the room.&#10;            await connection.ExecuteAsync(&quot;UPDATE rooms SET participant_count = @Count, ends_at = NOW() WHERE id = @RoomID&quot;, new&#10;            {&#10;                RoomID = room.RoomID,&#10;                Count = totalUsers,&#10;            });&#10;        }&#10;&#10;        public async Task&lt;multiplayer_playlist_item[]&gt; GetAllPlaylistItemsAsync(long roomId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return (await connection.QueryAsync&lt;multiplayer_playlist_item&gt;(&quot;SELECT * FROM playlists WHERE room_id = @RoomId&quot;, new { RoomId = roomId })).ToArray();&#10;        }&#10;&#10;        public async Task MarkScoreHasReplay(Score score)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&quot;UPDATE `scores` SET `has_replay` = 1 WHERE `id` = @scoreId&quot;, new&#10;            {&#10;                scoreId = score.ScoreInfo.OnlineID,&#10;            });&#10;        }&#10;&#10;        public async Task&lt;SoloScore?&gt; GetScoreFromTokenAsync(long token)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;SoloScore?&gt;(&#10;                &quot;SELECT * FROM `scores` WHERE `id` = (SELECT `score_id` FROM `score_tokens` WHERE `id` = @Id)&quot;, new&#10;                {&#10;                    Id = token&#10;                });&#10;        }&#10;&#10;        public async Task&lt;SoloScore?&gt; GetScoreAsync(long id)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;SoloScore?&gt;(&quot;SELECT * FROM `scores` WHERE `id` = @Id&quot;, new&#10;            {&#10;                Id = id&#10;            });&#10;        }&#10;&#10;        public Task&lt;bool&gt; IsScoreProcessedAsync(long scoreId)&#10;        {&#10;            // g0v0-server doesn't have score_process_history table&#10;            // For now, assume all scores are not processed to allow processing&#10;            return Task.FromResult(false);&#10;        }&#10;&#10;        public async Task&lt;phpbb_zebra?&gt; GetUserRelation(int userId, int zebraId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // g0v0-server uses relationship table instead of phpbb_zebra&#10;            var relationship = await connection.QuerySingleOrDefaultAsync&lt;dynamic&gt;(&quot;SELECT * FROM `relationship` WHERE `user_id` = @UserId AND `target_id` = @ZebraId&quot;, new&#10;            {&#10;                UserId = userId,&#10;                ZebraId = zebraId&#10;            });&#10;&#10;            if (relationship == null)&#10;                return null;&#10;&#10;            // Convert relationship to phpbb_zebra format for compatibility&#10;            return new phpbb_zebra&#10;            {&#10;                user_id = userId,&#10;                zebra_id = zebraId,&#10;                friend = relationship.type == &quot;Friend&quot;,&#10;                foe = relationship.type == &quot;Block&quot;&#10;            };&#10;        }&#10;&#10;        public async Task&lt;IEnumerable&lt;int&gt;&gt; GetUserFriendsAsync(int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // Query adapted for g0v0-server schema using relationship table&#10;            return await connection.QueryAsync&lt;int&gt;(&#10;                &quot;SELECT r.target_id FROM relationship r &quot;&#10;                + &quot;JOIN lazer_users u ON r.target_id = u.id &quot;&#10;                + &quot;WHERE r.user_id = @UserId &quot;&#10;                + &quot;AND r.type = 'Friend' &quot;&#10;                + &quot;AND u.priv = 1&quot;, new&#10;                {&#10;                    UserId = userId&#10;                });&#10;        }&#10;&#10;        public async Task&lt;bool&gt; GetUserAllowsPMs(int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // 在g0v0-server中，使用pm_friends_only字段（false表示允许所有人发送PM）&#10;            var pmFriendsOnly = await connection.QuerySingleOrDefaultAsync&lt;bool&gt;(&quot;SELECT `pm_friends_only` FROM `lazer_users` WHERE `id` = @UserId&quot;, new&#10;            {&#10;                UserId = userId&#10;            });&#10;            &#10;            // 如果pm_friends_only为false，表示允许所有人发送PM&#10;            return !pmFriendsOnly;&#10;        }&#10;&#10;        public async Task&lt;osu_build?&gt; GetBuildByIdAsync(int buildId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // g0v0-server doesn't have osu_builds table, return a dummy build&#10;            return new osu_build&#10;            {&#10;                build_id = (uint)buildId,&#10;                version = &quot;unknown&quot;,&#10;                hash = null,&#10;                users = 0&#10;            };&#10;        }&#10;&#10;        public Task&lt;IEnumerable&lt;osu_build&gt;&gt; GetAllMainLazerBuildsAsync()&#10;        {&#10;            // g0v0-server doesn't have osu_builds table, return empty list&#10;            return Task.FromResult&lt;IEnumerable&lt;osu_build&gt;&gt;(new List&lt;osu_build&gt;());&#10;        }&#10;&#10;        public Task&lt;IEnumerable&lt;osu_build&gt;&gt; GetAllPlatformSpecificLazerBuildsAsync()&#10;        {&#10;            // g0v0-server doesn't have osu_builds table, return empty list&#10;            return Task.FromResult&lt;IEnumerable&lt;osu_build&gt;&gt;(new List&lt;osu_build&gt;());&#10;        }&#10;&#10;        public Task UpdateBuildUserCountAsync(osu_build build)&#10;        {&#10;            // g0v0-server doesn't have osu_builds table, do nothing&#10;            return Task.CompletedTask;&#10;        }&#10;&#10;        public Task&lt;IEnumerable&lt;chat_filter&gt;&gt; GetAllChatFiltersAsync()&#10;        {&#10;            // g0v0-server doesn't have chat_filters table, return empty list&#10;            return Task.FromResult&lt;IEnumerable&lt;chat_filter&gt;&gt;(new List&lt;chat_filter&gt;());&#10;        }&#10;&#10;        public async Task&lt;IEnumerable&lt;multiplayer_room&gt;&gt; GetActiveDailyChallengeRoomsAsync()&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QueryAsync&lt;multiplayer_room&gt;(&#10;                &quot;SELECT * FROM `rooms` &quot;&#10;                + &quot;WHERE `category` = 'daily_challenge' &quot;&#10;                + &quot;AND `type` = 'playlists' &quot;&#10;                + &quot;AND `starts_at` &lt;= NOW() &quot;&#10;                + &quot;AND `ends_at` &gt; NOW()&quot;);&#10;        }&#10;&#10;        public async Task&lt;(long roomID, long playlistItemID)?&gt; GetMultiplayerRoomIdForScoreAsync(long scoreId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;(long, long)?&gt;(&#10;                &quot;SELECT `playlists`.`room_id`, `playlists`.`id` &quot;&#10;                + &quot;FROM `multiplayer_score_links` &quot;&#10;                + &quot;JOIN `playlists` &quot;&#10;                + &quot;ON `multiplayer_score_links`.`playlist_item_id` = `playlists`.`id` &quot;&#10;                + &quot;WHERE `multiplayer_score_links`.`score_id` = @scoreId&quot;,&#10;                new { scoreId = scoreId });&#10;        }&#10;&#10;        public async Task&lt;IEnumerable&lt;SoloScore&gt;&gt; GetPassingScoresForPlaylistItem(long playlistItemId, ulong afterScoreId = 0)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return (await connection.QueryAsync&lt;SoloScore&gt;(&#10;                &quot;SELECT `scores`.`id`, `scores`.`total_score` FROM `scores` &quot;&#10;                + &quot;JOIN `multiplayer_score_links` ON `multiplayer_score_links`.`score_id` = `scores`.`id` &quot;&#10;                + &quot;JOIN `lazer_users` ON `lazer_users`.`id` = `multiplayer_score_links`.`user_id` &quot;&#10;                + &quot;WHERE `scores`.`passed` = 1 &quot;&#10;                + &quot;AND `multiplayer_score_links`.`playlist_item_id` = @playlistItemId &quot;&#10;                + &quot;AND `multiplayer_score_links`.`score_id` &gt; @afterScoreId &quot;&#10;                + &quot;AND `lazer_users`.`priv` = 1&quot;, new&#10;                {&#10;                    playlistItemId = playlistItemId,&#10;                    afterScoreId = afterScoreId,&#10;                }));&#10;        }&#10;&#10;        public async Task&lt;multiplayer_scores_high?&gt; GetUserBestScoreAsync(long playlistItemId, int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            return await connection.QuerySingleOrDefaultAsync&lt;multiplayer_scores_high&gt;(&#10;                &quot;SELECT * FROM `multiplayer_scores_high` WHERE `playlist_item_id` = @playlistItemId AND `user_id` = @userId&quot;, new&#10;                {&#10;                    playlistItemId = playlistItemId,&#10;                    userId = userId&#10;                });&#10;        }&#10;&#10;        public async Task&lt;int&gt; GetUserRankInRoomAsync(long roomId, int userId)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            // g0v0-server doesn't have multiplayer_rooms_high table&#10;            // For now, return a default rank of 1&#10;            return 1;&#10;        }&#10;&#10;        public async Task LogRoomEventAsync(multiplayer_realtime_room_event ev)&#10;        {&#10;            var connection = await getConnectionAsync();&#10;&#10;            await connection.ExecuteAsync(&#10;                &quot;INSERT INTO `multiplayer_realtime_room_events` (`room_id`, `event_type`, `playlist_item_id`, `user_id`, `event_detail`, `created_at`, `updated_at`) &quot;&#10;                + &quot;VALUES (@room_id, @event_type, @playlist_item_id, @user_id, @event_detail, NOW(), NOW())&quot;,&#10;                ev);&#10;        }&#10;&#10;        public void Dispose()&#10;        {&#10;            openConnection?.Dispose();&#10;        }&#10;&#10;        private async Task&lt;MySqlConnection&gt; getConnectionAsync()&#10;        {&#10;            if (openConnection != null)&#10;                return openConnection;&#10;&#10;            DapperExtensions.InstallDateTimeOffsetMapper();&#10;&#10;            // 构建连接字符串，如果有密码则包含密码&#10;            string connectionString = string.IsNullOrEmpty(AppSettings.DatabasePassword)&#10;                ? $&quot;Server={AppSettings.DatabaseHost};Port={AppSettings.DatabasePort};Database={AppSettings.DatabaseName};User ID={AppSettings.DatabaseUser};ConnectionTimeout=5;ConnectionReset=false;Pooling=true;Pipelining=false&quot;&#10;                : $&quot;Server={AppSettings.DatabaseHost};Port={AppSettings.DatabasePort};Database={AppSettings.DatabaseName};User ID={AppSettings.DatabaseUser};Password={AppSettings.DatabasePassword};ConnectionTimeout=5;ConnectionReset=false;Pooling=true;Pipelining=false&quot;;&#10;&#10;            //打印连接字符串&#10;            logger.LogInformation(&quot;Connecting to database: {ConnectionString}&quot;, connectionString);&#10;&#10;            openConnection = new MySqlConnection(connectionString);&#10;&#10;            await openConnection.OpenAsync();&#10;&#10;            return openConnection;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>